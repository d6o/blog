[{"content":"A Journey Through Browsers: From Internet Explorer to LibreWolf\nThe internet has been a central part of my life for as long as I can remember. It all started in the early 2000s when my parents bought our first family computer. Back then, internet access was limited, and I could only use it on Saturdays after 2 pm because bandwidth was cheaper during off-peak hours. But those restrictions didn’t bother me; I was hooked on exploring the digital world. I spent countless hours trying to discover new game websites, looking for tips to beat my PlayStation games, or finding fun browser-based games. This was just the beginning.\nThe Early Days: Internet Explorer and Windows 98 Our computer came with Windows 98, and my first window into the internet was Internet Explorer 5. As slow and clunky as it was, it opened up a world of possibilities. One of my greatest early discoveries was learning how to \u0026ldquo;save pages\u0026rdquo; to read offline, a game-changer given our limited internet time. As I became more comfortable with the web, I stumbled across the Brazilian website Baixaki, which was a treasure trove of downloadable software. But since my internet connection was slow, downloads would often take the entire weekend, which only added to the anticipation.\nDiscovering Firefox: A Game Changer While exploring Baixaki, I came across Firefox, and it was like a breath of fresh air. Firefox was faster, more efficient, and for the first time, I felt like I was truly experiencing the potential of the internet. Soon after, I switched to Firefox, making it my default browser and never looking back. Around this time, I even tried a browser with a red dinosaur logo, but its name escapes me now. It wasn’t long before Firefox 1.5 came, followed by Firefox 2, which solidified my loyalty to this browser as I dived deeper into web development and coding.\nEnter Chrome: A Revolution Then came Google Chrome. Its release felt revolutionary. While Firefox had become somewhat resource-heavy and sluggish, Chrome was lightning fast and efficient. Still, early versions of Chrome had some quirks. I remember one in particular—if you closed the browser while downloading something, it would cancel the download without warning. This frustration kept me from switching right away, but I knew that in time, Chrome would resolve these issues. And it did, with fast release cycles that I wasn’t used to in the era of slow software updates.\nAs a noob web developer, part of me hesitated to fully switch due to Firefox’s amazing Web Developer toolbar addon, but over time, Chrome won me over with its speed and simplicity.\nOpera, RockMelt, and Other Adventures Around this period, I also experimented with Opera. It was always highly praised in forums, touted as being faster and more secure than its competitors. While Opera had its moments, there was always something that didn’t quite fit my workflow, and I would inevitably return to Chrome.\nFor a brief but fun period, I switched to RockMelt, a Chromium fork designed for social media interaction. It allowed me to chat and interact with my contacts without having to open social media sites. It was short-lived, but it was a novel concept that reflected how browsers were becoming more than just tools for browsing—they were evolving into comprehensive digital platforms.\nChromium and the Quest for Privacy As my online habits matured, so did my concern for privacy and security. I eventually moved to Ungoogled-Chromium, a more privacy-focused version of Chrome. This was a significant step for me, but as my browsing habits became more plugin-dependent, every attempt to switch back to Firefox failed. Firefox simply didn’t have all the plugins I relied on.\nI stuck with Ungoogled-Chromium for several years, appreciating its minimalist and privacy-centered design. However, life threw a curveball when the company I was working for decided that we could only use \u0026ldquo;verified\u0026rdquo; browsers. That’s when I decided to give Firefox another shot.\nBack to Firefox and the Move to LibreWolf This time, switching back to Firefox was a success. For almost two years, I used Firefox as my main browser, enjoying its flexibility and privacy tools. But as I continued to refine my approach to security and data ownership, I became intrigued by the idea of a browser that was privacy-focused right out of the box. This led me to LibreWolf.\nLibreWolf promised everything I wanted: strong privacy settings, no telemetry, and complete control over my browsing experience. I made the switch recently, and along with it, I set up my own Firefox Sync server, giving me full ownership of my data. It’s an exciting new chapter in my ongoing journey through the world of browsers, and I’m eager to see where this path leads next.\nThe Browser Journey Continues… Looking back, my browser journey has been a fascinating ride through the evolution of the internet itself. From the early days of Internet Explorer and slow, dial-up connections, to Firefox, Chrome, and now LibreWolf, each browser represents a stage of growth in my digital life.\nI doubt this is the last chapter in my story with browsers, but I’m excited about what’s to come. Browsers have come a long way from being simple tools for accessing the web to becoming powerful platforms for privacy, productivity, and creativity. Who knows what the next leap will be? Until then, I’ll continue exploring, learning, and tweaking as I go.\n","permalink":"https://blog.diego.dev/posts/internet-browsers/","summary":"A Journey Through Browsers: From Internet Explorer to LibreWolf\nThe internet has been a central part of my life for as long as I can remember. It all started in the early 2000s when my parents bought our first family computer. Back then, internet access was limited, and I could only use it on Saturdays after 2 pm because bandwidth was cheaper during off-peak hours. But those restrictions didn’t bother me; I was hooked on exploring the digital world.","title":"My Journey Through Browsers: From Internet Explorer to LibreWolf"},{"content":"In this post, we\u0026rsquo;ll walk through how to use Go to subscribe to new blocks on the Ethereum blockchain and print out the transaction hashes for each block. This is a common task when working with Ethereum, especially for monitoring or analytics purposes.\nPrerequisites Before we start, make sure you have the following:\nGo installed on your machine.\nAccess to an Ethereum node. You can use a service like Infura or run your own Ethereum node.\nThe Go-Ethereum package (go-ethereum) installed. You can install it with:\ngo get github.com/ethereum/go-ethereum Step 1: Setting Up the Project First, create a new Go project and initialize it:\nmkdir eth-subscribe cd eth-subscribe go mod init eth-subscribe Next, we\u0026rsquo;ll need to import the necessary packages. Create a main.go file and add the following imports:\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/ethereum/go-ethereum\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/rpc\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/core/types\u0026#34; ) Step 2: Connecting to an Ethereum Node To interact with the Ethereum blockchain, we need to connect to an Ethereum node. For this example, we\u0026rsquo;ll use an Infura endpoint, but you can replace the URL with your own node\u0026rsquo;s address.\nfunc main() { // Replace with your Infura project ID or node address client, err := ethclient.Dial(\u0026#34;wss://mainnet.infura.io/ws/v3/YOUR_INFURA_PROJECT_ID\u0026#34;) if err != nil { log.Fatalf(\u0026#34;Failed to connect to the Ethereum client: %v\u0026#34;, err) } defer client.Close() // Create a new context ctx := context.Background() // Subscribe to new block headers headerCh := make(chan *types.Header) sub, err := client.SubscribeNewHead(ctx, headerCh) if err != nil { log.Fatalf(\u0026#34;Failed to subscribe to new headers: %v\u0026#34;, err) } for { select { case err := \u0026lt;-sub.Err(): log.Fatalf(\u0026#34;Subscription error: %v\u0026#34;, err) case header := \u0026lt;-headerCh: processBlock(header, client) } } } Step 3: Processing the Block Once we have a new block header, we can use it to fetch the block and print out the transaction hashes:\nfunc processBlock(header *types.Header, client *ethclient.Client) { block, err := client.BlockByHash(context.Background(), header.Hash()) if err != nil { log.Printf(\u0026#34;Failed to get block: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;New block #%d with %d transactions\u0026#34;, block.Number().Uint64(), len(block.Transactions())) for _, tx := range block.Transactions() { fmt.Printf(\u0026#34;Transaction hash: %s\u0026#34;, tx.Hash().Hex()) } } Step 4: Running the Program Finally, you can run your program to start subscribing to new blocks and printing out the transaction hashes:\ngo run main.go As new blocks are mined on the Ethereum network, your program will output the block number along with the hashes of all the transactions included in each block.\nConclusion In this tutorial, we have built a simple Go program that subscribes to new blocks on the Ethereum network and prints out the transaction hashes. This is a foundational task for many blockchain applications, such as monitoring transactions, building analytics tools, or creating decentralized applications (dApps).\nFeel free to expand this example by filtering transactions, tracking specific contracts, or integrating with a database to store the block data for further analysis.\n","permalink":"https://blog.diego.dev/posts/subscribe-ethereum-blocks-print-transaction-hashes/","summary":"In this post, we\u0026rsquo;ll walk through how to use Go to subscribe to new blocks on the Ethereum blockchain and print out the transaction hashes for each block. This is a common task when working with Ethereum, especially for monitoring or analytics purposes.\nPrerequisites Before we start, make sure you have the following:\nGo installed on your machine.\nAccess to an Ethereum node. You can use a service like Infura or run your own Ethereum node.","title":"Using Go to Subscribe to Ethereum New Blocks and Print Transaction Hashes"}]